#!/usr/bin/env python3
#
#  This file is licensed under the MIT license
#  This file originates from https://github.com/caseychu/spotify-backup

import base64
import codecs
import hashlib
import http.client
import http.server
import json
import os
import re
import sys
import time
import urllib.error
import urllib.parse
import urllib.request
import webbrowser


class SpotifyAPI:
    """Class to interact with the Spotify API using an OAuth token."""

    BASE_URL = "https://api.spotify.com/v1/"

    def __init__(self, auth):
        self._auth = auth

    def get(self, url, params={}, tries=3):
        """Fetch a resource from Spotify API."""
        url = self._construct_url(url, params)
        for _ in range(tries):
            try:
                req = self._create_request(url)
                return self._read_response(req)
            except Exception as err:
                print(f"Error fetching URL {url}: {err}")
                time.sleep(2)
        sys.exit("Failed to fetch data from Spotify API after retries.")

    def list(self, url, params={}):
        """Fetch paginated resources and return as a combined list."""
        response = self.get(url, params)
        items = response["items"]

        while response["next"]:
            response = self.get(response["next"])
            items += response["items"]
        return items

    @staticmethod
    def authorize(client_id, scope):
        """Open a browser for user authorization and return SpotifyAPI instance."""
        redirect_uri = f"http://127.0.0.1:{SpotifyAPI._SERVER_PORT}/redirect"
        
        # Generate PKCE parameters
        code_verifier = SpotifyAPI._generate_code_verifier()
        code_challenge = SpotifyAPI._generate_code_challenge(code_verifier)
        
        url = SpotifyAPI._construct_auth_url(client_id, scope, redirect_uri, code_challenge)
        print(f"Open this link if the browser doesn't open automatically: {url}")
        webbrowser.open(url)

        server = SpotifyAPI._AuthorizationServer("127.0.0.1", SpotifyAPI._SERVER_PORT, client_id, code_verifier, redirect_uri)
        try:
            while True:
                server.handle_request()
        except SpotifyAPI._Authorization as auth:
            if auth.access_token is None:
                print(f"ERROR: Authorization failed - {auth.error}")
                sys.exit(1)
            return SpotifyAPI(auth.access_token)

    @staticmethod
    def _generate_code_verifier():
        """Generate a code verifier for PKCE."""
        return base64.urlsafe_b64encode(os.urandom(32)).decode('utf-8').rstrip('=')
    
    @staticmethod
    def _generate_code_challenge(code_verifier):
        """Generate a code challenge from the verifier."""
        digest = hashlib.sha256(code_verifier.encode('utf-8')).digest()
        return base64.urlsafe_b64encode(digest).decode('utf-8').rstrip('=')

    @staticmethod
    def _construct_auth_url(client_id, scope, redirect_uri, code_challenge):
        return "https://accounts.spotify.com/authorize?" + urllib.parse.urlencode(
            {
                "response_type": "code",
                "client_id": client_id,
                "scope": scope,
                "redirect_uri": redirect_uri,
                "code_challenge_method": "S256",
                "code_challenge": code_challenge,
            }
        )

    def _construct_url(self, url, params):
        """Construct a full API URL."""
        if not url.startswith(self.BASE_URL):
            url = self.BASE_URL + url
        if params:
            url += ("&" if "?" in url else "?") + urllib.parse.urlencode(params)
        return url

    def _create_request(self, url):
        """Create an authenticated request."""
        req = urllib.request.Request(url)
        req.add_header("Authorization", f"Bearer {self._auth}")
        return req

    def _read_response(self, req):
        """Read and parse the response."""
        with urllib.request.urlopen(req) as res:
            reader = codecs.getreader("utf-8")
            return json.load(reader(res))

    _SERVER_PORT = 43019

    class _AuthorizationServer(http.server.HTTPServer):
        def __init__(self, host, port, client_id, code_verifier, redirect_uri):
            self.client_id = client_id
            self.code_verifier = code_verifier
            self.redirect_uri = redirect_uri
            super().__init__((host, port), SpotifyAPI._AuthorizationHandler)

        def handle_error(self, request, client_address):
            raise

    class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path.startswith("/redirect"):
                self._handle_redirect()
            else:
                self.send_error(404)

        def _handle_redirect(self):
            # Parse the authorization code from the query parameters
            query = urllib.parse.urlparse(self.path).query
            params = urllib.parse.parse_qs(query)
            
            if 'error' in params:
                self.send_response(400)
                self.send_header("Content-Type", "text/html")
                self.end_headers()
                error = params['error'][0]
                self.wfile.write(f"<script>window.close()</script>Error: {error}".encode())
                raise SpotifyAPI._Authorization(None, error=error)
            
            if 'code' not in params:
                self.send_response(400)
                self.send_header("Content-Type", "text/html")
                self.end_headers()
                self.wfile.write(b"<script>window.close()</script>No authorization code received.")
                raise SpotifyAPI._Authorization(None, error="No code")
            
            auth_code = params['code'][0]
            
            # Send response to close the window
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.end_headers()
            self.wfile.write(
                b"<script>window.close()</script>Thanks! You may now close this window."
            )
            
            # Exchange the code for an access token
            access_token = self._exchange_code_for_token(auth_code)
            raise SpotifyAPI._Authorization(access_token)
        
        def _exchange_code_for_token(self, auth_code):
            """Exchange the authorization code for an access token."""
            token_url = "https://accounts.spotify.com/api/token"
            
            data = {
                "grant_type": "authorization_code",
                "code": auth_code,
                "redirect_uri": self.server.redirect_uri,
                "client_id": self.server.client_id,
                "code_verifier": self.server.code_verifier,
            }
            
            req = urllib.request.Request(
                token_url,
                data=urllib.parse.urlencode(data).encode('utf-8'),
                method='POST'
            )
            
            try:
                with urllib.request.urlopen(req) as response:
                    response_data = json.loads(response.read().decode('utf-8'))
                    return response_data.get('access_token')
            except urllib.error.HTTPError as e:
                print(f"Error exchanging code for token: {e.read().decode('utf-8')}")
                raise

        def log_message(self, format, *args):
            pass

    class _Authorization(Exception):
        def __init__(self, access_token, error=None):
            self.access_token = access_token
            self.error = error


def fetch_user_data(spotify, dump):
    """Fetch playlists and liked songs based on the dump parameter."""
    playlists = []
    liked_albums = []

    try:
        if "liked" in dump:
            print("Loading liked albums and songs...")
            liked_tracks = spotify.list("me/tracks", {"limit": 50})
            liked_albums = spotify.list("me/albums", {"limit": 50})
            print(f"  - Loaded {len(liked_tracks)} liked tracks")
            print(f"  - Loaded {len(liked_albums)} liked albums")
            playlists.append({"name": "Liked Songs", "tracks": liked_tracks})

        if "playlists" in dump:
            print("Loading playlists...")
            playlist_data = spotify.list("me/playlists", {"limit": 50})
            print(f"  - Found {len(playlist_data)} playlists")
            for playlist in playlist_data:
                try:
                    print(f"Loading playlist: {playlist['name']}", flush=True)
                except Exception as e:
                    print(f"Loading playlist: [name with special chars]", flush=True)
                try:
                    tracks = spotify.list(playlist["tracks"]["href"], {"limit": 100})
                    playlist["tracks"] = tracks
                    print(f"  - Loaded {len(tracks)} tracks")
                except Exception as e:
                    print(f"  - Error loading tracks: {e}")
                    playlist["tracks"] = []
            playlists.extend(playlist_data)

        return playlists, liked_albums
    except Exception as e:
        print(f"ERROR fetching user data: {e}")
        raise


def write_to_file(file, format, playlists, liked_albums):
    """Write fetched data to a file in the specified format."""
    print(f"Writing to {file}...")
    print(f"Total playlists: {len(playlists)}")
    print(f"Total liked albums: {len(liked_albums)}")
    
    with open(file, "w", encoding="utf-8") as f:
        if format == "json":
            json.dump({"playlists": playlists, "albums": liked_albums}, f, indent=2, ensure_ascii=False)
        else:
            for playlist in playlists:
                f.write(playlist["name"] + "\r\n")
                for track in playlist["tracks"]:
                    if track["track"]:
                        f.write(
                            "{name}\t{artists}\t{album}\t{uri}\t{release_date}\r\n".format(
                                uri=track["track"]["uri"],
                                name=track["track"]["name"],
                                artists=", ".join(
                                    [
                                        artist["name"]
                                        for artist in track["track"]["artists"]
                                    ]
                                ),
                                album=track["track"]["album"]["name"],
                                release_date=track["track"]["album"]["release_date"],
                            )
                        )
                f.write("\r\n")
    
    # Verify file was written
    if os.path.exists(file):
        file_size = os.path.getsize(file)
        print(f"âœ“ File written successfully ({file_size} bytes)")


def main(dump="playlists,liked", format="json", file="playlists.json", token=""):
    print("Starting backup...")
    spotify = (
        SpotifyAPI(token)
        if token
        else SpotifyAPI.authorize(
            client_id="5c098bcc800e45d49e476265bc9b6934",
            scope="playlist-read-private playlist-read-collaborative user-library-read",
        )
    )

    playlists, liked_albums = fetch_user_data(spotify, dump)
    write_to_file(file, format, playlists, liked_albums)
    print(f"Backup completed! Data written to {file}")


if __name__ == "__main__":
    main()
